<!doctype html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1 vs 100 | Host</title>
    <link rel="stylesheet" href="/styles.css" />
    <script src="/socket.io/socket.io.js"></script>
  </head>
  <body>
    <header>
      <div>
        <h1>Moderator-Ansicht</h1>
        <p>Steuere Fragen, eliminiere falsche Antworten und behalte die Mob-Grösse im Blick.</p>
      </div>
      <div class="badge" id="mob-count">Mob: --</div>
    </header>

    <main class="grid two">
      <section class="card">
        <h2>Spielsteuerung</h2>
        <p id="stage">Status: Lobby</p>
        <div class="grid two">
          <button id="start-question">Nächste Frage</button>
          <button id="reveal-answer" disabled>Antwort auswerten</button>
          <button id="reset-game">Mob zurücksetzen</button>
        </div>
        <p class="footer-note">
          Starte eine Frage, lass die Spieler tippen und löse dann die korrekte Antwort auf, um falsche Spieler zu
          eliminieren.
        </p>
      </section>

      <section class="card" id="question-card">
        <h2>Aktuelle Frage</h2>
        <div id="question-text">Noch keine Frage gestartet.</div>
        <div class="option-grid" id="options"></div>
      </section>

      <section class="card">
        <h2>Spielerübersicht</h2>
        <ul class="list" id="players"></ul>
      </section>
    </main>

    <script>
      const socket = io();
      let currentQuestion = null;

      socket.emit('join', { role: 'host', name: 'Host' });

      socket.on('state', (state) => {
        renderState(state);
      });

      socket.on('question-started', (question) => {
        currentQuestion = question;
        renderQuestion(question);
        document.getElementById('reveal-answer').disabled = false;
      });

      socket.on('question-reveal', ({ correctIndex, eliminated, mobAlive }) => {
        document.getElementById('reveal-answer').disabled = true;
        highlightOptions(correctIndex);
        document.getElementById('mob-count').innerText = `Mob: ${mobAlive}`;
        if (eliminated.length > 0) {
          document.getElementById('stage').innerText = `Ergebnis: ${eliminated.length} Spieler eliminiert`;
        }
      });

      socket.on('game-reset', () => {
        currentQuestion = null;
        document.getElementById('reveal-answer').disabled = true;
        document.getElementById('question-text').innerText = 'Mob zurückgesetzt. Bereit für eine neue Runde!';
        document.getElementById('options').innerHTML = '';
      });

      socket.on('host-control', (state) => {
        if (state.mobAlive !== undefined) {
          document.getElementById('mob-count').innerText = `Mob: ${state.mobAlive}`;
        }
      });

      document.getElementById('start-question').addEventListener('click', () => {
        socket.emit('host-start-question');
      });

      document.getElementById('reveal-answer').addEventListener('click', () => {
        socket.emit('host-reveal-answer');
      });

      document.getElementById('reset-game').addEventListener('click', () => {
        socket.emit('host-reset-game');
      });

      function renderState(state) {
        document.getElementById('stage').innerText = `Status: ${state.stage}`;
        document.getElementById('mob-count').innerText = `Mob: ${state.mobAlive}`;
        const list = document.getElementById('players');
        list.innerHTML = '';
        state.players
          .sort((a, b) => b.score - a.score)
          .forEach((player) => {
            const item = document.createElement('li');
            item.innerHTML = `
              <span>${player.name}</span>
              <span>${player.score} Punkte · ${player.status === 'alive' ? 'im Spiel' : 'ausgeschieden'}${
              player.answered ? ' · Antwort gesendet' : ''
            }</span>`;
            list.appendChild(item);
          });
        if (state.activeQuestion) {
          currentQuestion = state.activeQuestion;
          renderQuestion(currentQuestion);
          document.getElementById('reveal-answer').disabled = false;
        }
      }

      function renderQuestion(question) {
        document.getElementById('question-text').innerText = `Frage ${question.number}/${question.total}: ${question.prompt}`;
        const container = document.getElementById('options');
        container.innerHTML = '';
        question.options.forEach((text, idx) => {
          const option = document.createElement('div');
          option.className = 'option';
          option.innerText = text;
          option.dataset.index = idx;
          container.appendChild(option);
        });
      }

      function highlightOptions(correctIndex) {
        const container = document.getElementById('options');
        container.querySelectorAll('.option').forEach((node) => {
          const idx = Number(node.dataset.index);
          node.classList.remove('selected');
          node.classList.add(idx === correctIndex ? 'correct' : 'wrong');
        });
      }
    </script>
  </body>
</html>
